// use deserializers::question::ProblemSetQuestionList;
use leetcode_tui_rs::config::{self, Config};
// use leetcode_tui_rs::db_ops::ModelUtils;
use leetcode_tui_rs::deserializers;
// use leetcode_tui_rs::deserializers::question::Question;
// use leetcode_tui_rs::graphql::problemset_question_list::Query;
// use leetcode_tui_rs::graphql::GQLLeetcodeQuery;
use reqwest::header::{HeaderMap, HeaderValue};
// use sea_orm::Database;
// use tracing;
// use tracing_subscriber;

use leetcode_tui_rs::app_ui::app::{App, AppResult, TTReciever};
use leetcode_tui_rs::app_ui::event::{Event, EventHandler};
use leetcode_tui_rs::app_ui::handler::handle_key_events;
use leetcode_tui_rs::app_ui::tui::Tui;
use ratatui::backend::CrosstermBackend;
use ratatui::Terminal;
use sea_orm::Database;
use std::io;

use once_cell::sync::Lazy;

static CONFIG: Lazy<config::Config> = Lazy::new(|| Config::from_file("./leetcode.config"));

// static CLIENT: Lazy<reqwest::Client> = Lazy::new(|| {
//     let csrf = CONFIG.leetcode.csrftoken.as_str();
//     let sess = CONFIG.leetcode.leetcode_session.as_str();
//     let mut headers = HeaderMap::new();
//     headers.append(
//         "Cookie",
//         HeaderValue::from_str(&format!("LEETCODE_SESSION={sess}; csrftoken={csrf}")).unwrap(),
//     );
//     reqwest::ClientBuilder::new()
//         .default_headers(headers)
//         .build()
//         .unwrap()
// });

#[tokio::main]
async fn main() -> AppResult<()> {
    // tracing_subscriber::fmt()
    //     .with_max_level(tracing::Level::DEBUG)
    //     .with_test_writer()
    //     .init();

    // tokio::task::spawn_blocking(|| {
    //     run_it();
    // });

    let DATABASE_CLIENT = Database::connect(CONFIG.db.url.as_str()).await.unwrap();

    // let query = Query::default();
    // let questions: ProblemSetQuestionList = query.post(&CLIENT).await;
    // Question::multi_insert(&DATABASE_CLIENT, questions.questions).await;
    //
    //
    //

    // Create an application.
    let (send, recv) = tokio::sync::mpsc::channel(300);

    let mut q = leetcode_tui_rs::db_ops::topic_tag::query::get_questions_by_topic(
        &DATABASE_CLIENT,
        "",
    )
    .await;
    dbg!(&q);

    while !q.is_empty() {
        let qp = q.pop();
        if let Some(qp) = qp {
            send.send(qp).await.unwrap();
        };
    }

    tokio::task::spawn_blocking(|| run_app(recv).unwrap());

    Ok(())
}

fn run_app(recv: TTReciever) -> AppResult<()> {
    let mut app = App::new(recv);

    // Initialize the terminal user interface.
    let backend = CrosstermBackend::new(io::stderr());
    let terminal = Terminal::new(backend)?;
    let events = EventHandler::new(50);
    let mut tui = Tui::new(terminal, events);
    tui.init()?;

    // Start the main loop.
    while app.running {
        // Render the user interface.
        tui.draw(&mut app)?;
        // Handle events.
        match tui.events.next()? {
            Event::Tick => app.tick(),
            Event::Key(key_event) => handle_key_events(key_event, &mut app)?,
            Event::Mouse(_) => {}
            Event::Resize(_, _) => {}
        }
    }

    // Exit the user interface.
    tui.exit()?;
    Ok(())
}
